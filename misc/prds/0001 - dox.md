# RFC: Dox - Container Command Wrapper Specification

**Version**: 1.0.0
**Status**: Draft
**Date**: January 2025

## 1. Introduction

### 1.1 Purpose
Dox is a lightweight wrapper utility that transparently executes commands within Docker or Podman containers while maintaining the user experience of native host commands. It eliminates the need to install tools directly on the host system by running them in isolated, reproducible container environments.

### 1.2 Goals
- Provide seamless integration of containerised tools with host system workflows
- Maintain full compatibility with shell scripts, pipes, and process management
- Enable reproducible development environments without system pollution
- Support both pre-built container images and custom inline Dockerfile definitions

### 1.3 Background
Modern development workflows often require numerous tools with complex dependencies. Installing these directly on the host system can lead to version conflicts, dependency hell, and system bloat. Dox addresses these issues by containerising individual commands while preserving their native behaviour.

## 2. Requirements

### 2.1 Functional Requirements

#### Must Have (P0)
- FR-001: Execute containerised commands with syntax `dox <command> [args...]`
- FR-002: Pass all arguments transparently to the containerised command
- FR-003: Preserve exit codes from containerised processes
- FR-004: Forward all signals (SIGINT, SIGTERM, etc.) to container processes
- FR-005: Support both Docker and Podman runtimes
- FR-006: Mount current working directory to `/workspace` in container
- FR-007: Run processes with host UID/GID to maintain file permissions
- FR-008: Support environment variable passthrough
- FR-009: Provide built-in commands: list, version, upgrade, upgrade-all, clean
- FR-010: Support both pre-built images and inline Dockerfile builds

#### Should Have (P1)
- FR-011: Support multiple volume mounts with environment variable expansion
- FR-012: Enable read-only volume mounts
- FR-013: Auto-detect host architecture for image builds
- FR-014: Support concurrent execution of the same command
- FR-015: Provide meaningful error messages for missing configurations

#### Nice to Have (P2)
- FR-016: Future support for configuration validation command
- FR-017: Future support for GUI applications
- FR-018: Future support for remote configuration repositories

### 2.2 Non-Functional Requirements

#### Performance
- NFR-001: Container startup overhead must not exceed 3 seconds
- NFR-002: No additional latency for stdio operations
- NFR-003: Efficient use of Docker build cache

#### Usability
- NFR-004: Commands must behave identically to native executables
- NFR-005: No output interjection from dox itself during command execution
- NFR-006: Support standard shell features (pipes, redirects, job control)

#### Reliability
- NFR-007: Graceful handling of Docker daemon unavailability
- NFR-008: Proper cleanup of terminated containers
- NFR-009: Consistent behaviour across Docker and Podman

#### Portability
- NFR-010: Single static binary distribution
- NFR-011: XDG Base Directory compliance for configuration
- NFR-012: Cross-platform support (Linux, macOS with Docker Desktop)

## 3. Architecture

### 3.1 System Architecture

```
┌─────────────────────────────────────────────────────────┐
│                     User Shell                          │
└────────────────┬────────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────────┐
│                    Dox Binary                           │
│  ┌───────────────────────────────────────────────────┐  │
│  │              CLI Parser (Cobra)                   │  │
│  └───────────────┬───────────────────────────────────┘  │
│                  │                                       │
│  ┌───────────────▼────────────┐ ┌────────────────────┐ │
│  │   Config Manager (Viper)   │ │  Command Registry  │ │
│  │  - Load YAML configs        │ │  - List commands   │ │
│  │  - Expand env vars          │ │  - Validate exists │ │
│  └───────────────┬────────────┘ └────────────────────┘ │
│                  │                                       │
│  ┌───────────────▼────────────────────────────────────┐ │
│  │           Container Runtime Abstraction            │ │
│  │  ┌──────────────┐        ┌──────────────────────┐ │ │
│  │  │ Docker Client│        │   Podman Client     │ │ │
│  │  └──────────────┘        └──────────────────────┘ │ │
│  └───────────────┬────────────────────────────────────┘ │
└──────────────────┼───────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│          Container Runtime (Docker/Podman)              │
└─────────────────────────────────────────────────────────┘
```

### 3.2 Component Descriptions

#### CLI Parser
- Parses command-line arguments using Cobra framework
- Distinguishes between dox arguments and command arguments
- Routes to appropriate handlers (built-in commands or container execution)

#### Config Manager
- Loads global configuration from `${XDG_CONFIG_HOME}/dox/config.yaml`
- Loads command-specific configuration from `${XDG_CONFIG_HOME}/dox/commands/<command>.yaml`
- Expands environment variables in volume paths
- Validates configuration structure

#### Command Registry
- Maintains inventory of available commands
- Provides command discovery for `dox list`
- Validates command existence before execution

#### Container Runtime Abstraction
- Provides unified interface for Docker and Podman operations
- Handles runtime-specific API differences
- Manages container lifecycle (create, start, attach, remove)

### 3.3 Execution Flow

```
1. User executes: dox claude "write a function"
2. CLI parser identifies:
   - Command: claude
   - Arguments: ["write a function"]
3. Config manager loads claude.yaml
4. Runtime abstraction:
   a. Checks/builds required image
   b. Creates container with:
      - Image from config
      - Volume mounts
      - Environment variables
      - Host UID/GID
      - Network mode: host
      - Interactive TTY
   c. Starts container
   d. Attaches to container stdio
   e. Executes command with arguments
5. Signal forwarding active
6. Container exit code returned to shell
7. Container removed (--rm flag)
```

## 4. Data Handling

### 4.1 Configuration Data Model

#### Global Configuration Schema
```yaml
# ${XDG_CONFIG_HOME}/dox/config.yaml
runtime: string  # "docker" | "podman", default: "docker"
```

#### Command Configuration Schema
```yaml
# ${XDG_CONFIG_HOME}/dox/commands/<command>.yaml
image: string           # Required: image name with tag
build:                  # Optional: build configuration
  dockerfile_inline: string  # Inline Dockerfile content
volumes:                # Optional: volume mount list
  - string              # Format: "source:target[:ro]"
environment:            # Optional: environment variables
  - string              # Variable names to pass through
command: string         # Optional: override entrypoint
```

### 4.2 Configuration Processing

#### Environment Variable Expansion
Variables in volume paths are expanded:
- `${HOME}` → User's home directory
- `${XDG_CONFIG_HOME}` → User's config directory
- `.` → Current working directory (special case)

#### Volume Mount Processing
```
Input:  "${HOME}/.ssh:/home/user/.ssh:ro"
Parsed: {
  Source: "/home/username/.ssh",
  Target: "/home/user/.ssh",
  ReadOnly: true
}
```

### 4.3 State Management
- No persistent state between executions
- All configuration read fresh on each invocation
- Docker build cache provides image layer persistence

## 5. API Design

### 5.1 Command-Line Interface

#### Primary Command
```bash
dox <command> [arguments...]
```

#### Built-in Commands
```bash
dox                      # Show help
dox list                 # List available commands
dox version              # Show dox version
dox upgrade <command>    # Upgrade specific command image
dox upgrade-all          # Upgrade all non-SHA-pinned images
dox clean                # Remove unused containers
```

### 5.2 Docker API Usage

#### Container Creation Parameters
```go
type ContainerConfig struct {
    Image        string
    Cmd          []string
    Env          []string
    WorkingDir   string
    User         string  // "UID:GID"
    AttachStdin  bool    // true
    AttachStdout bool    // true
    AttachStderr bool    // true
    Tty          bool    // true
    OpenStdin    bool    // true
}

type HostConfig struct {
    AutoRemove   bool       // true
    NetworkMode  string     // "host"
    Binds        []string   // Volume mounts
}
```

## 6. Error Handling

### 6.1 Error Categories

#### Configuration Errors
- E001: Command not found - "Command 'X' doesn't exist"
- E002: Config file missing - "Configuration file not found. Create ${XDG_CONFIG_HOME}/dox/commands/X.yaml"
- E003: Invalid YAML - "Failed to parse configuration: [details]"
- E004: Missing required field - "Configuration missing required field: image"

#### Runtime Errors
- E101: Docker not available - "Docker daemon not responding. Is Docker running?"
- E102: Image pull failed - "Failed to pull image: [details]"
- E103: Build failed - "Failed to build image: [details]"
- E104: Container creation failed - "Failed to create container: [details]"

#### Execution Errors
- E201: Command failed - Return original exit code
- E202: Signal handling failed - "Failed to forward signal: [details]"

### 6.2 Error Response Strategy
- Configuration errors: Exit with descriptive message and remediation steps
- Runtime errors: Exit with error details and potential fixes
- Execution errors: Preserve original command behaviour and exit code

## 7. Performance Considerations

### 7.1 Startup Optimisation
- Accept 1-3 second container creation overhead
- Utilise Docker build cache for inline Dockerfiles
- No pre-warming or daemon mode in v1

### 7.2 Resource Management
- Automatic container removal prevents resource leaks
- Rely on Docker's default resource limits
- No custom CPU/memory constraints in v1

### 7.3 Build Performance
- Standard Docker build cache utilisation
- Multi-stage builds supported in inline Dockerfiles
- Architecture-specific builds auto-detected

## 8. Security Measures

### 8.1 Container Isolation
- Containers run with host network mode (security trade-off for functionality)
- File system access limited to explicitly mounted volumes
- No privileged container execution

### 8.2 User Permissions
- Containers run as host UID/GID
- Prevents permission escalation
- Maintains file ownership consistency

### 8.3 Configuration Security
- User-controlled configuration files
- No remote configuration fetching in v1
- Environment variables not logged or exposed

## 9. Testing Plan

### 9.1 Unit Testing

#### Config Package
- YAML parsing with valid/invalid configurations
- Environment variable expansion
- Volume mount parsing
- Command discovery

#### Runtime Package
- Docker client initialisation
- Container parameter construction
- Signal forwarding logic
- Exit code preservation

### 9.2 Integration Testing

#### Docker Integration
- Container creation and execution
- Volume mount verification
- Environment variable passthrough
- Build from inline Dockerfile

#### Podman Compatibility
- Basic operations with Podman runtime
- API compatibility verification

### 9.3 End-to-End Testing

#### Test Scenarios
1. **Basic Execution**
   ```bash
   echo "print('Hello')" > test.py
   dox python test.py
   # Verify: Output "Hello", exit code 0
   ```

2. **Signal Handling**
   ```bash
   dox sleep 30 &
   PID=$!
   sleep 1
   kill -INT $PID
   # Verify: Process terminates cleanly
   ```

3. **File Permission Preservation**
   ```bash
   touch testfile
   dox touch testfile2
   # Verify: Both files have same ownership
   ```

4. **Concurrent Execution**
   ```bash
   dox sleep 5 &
   dox sleep 5 &
   # Verify: Both execute without conflict
   ```

## 10. Implementation Timeline

### Phase 1: Core Foundation (Week 1-2)
- Project structure setup
- Basic CLI with Cobra
- Config loading with Viper
- Docker client integration

### Phase 2: Container Execution (Week 2-3)
- Container creation and execution
- Signal forwarding
- Exit code handling
- Volume mounting

### Phase 3: Image Management (Week 3-4)
- Image pulling
- Inline Dockerfile builds
- Upgrade commands
- Clean command

### Phase 4: Polish and Testing (Week 4-5)
- Podman support
- Comprehensive testing
- Documentation
- Binary releases

## 11. Open Questions and Future Considerations

### 11.1 Deferred Features
- **GUI Support**: X11/Wayland forwarding complexity deferred
- **Daemon Mode**: Persistent containers for reduced startup time
- **Configuration Validation**: `dox validate` command
- **Remote Configurations**: Repository-based command definitions
- **Resource Limits**: CPU/memory constraints
- **Advanced Networking**: Custom network configurations

### 11.2 Unresolved Questions
1. Should dox support Docker Compose files as an alternative to individual YAML configs?
2. How should dox handle commands that need Docker socket access?
3. Should there be a mechanism for command versioning?
4. Is there value in supporting Windows containers?

### 11.3 Future Enhancements
- **Performance**: Investigate container reuse strategies
- **Security**: Add rootless container support
- **Usability**: Shell completion scripts
- **Ecosystem**: Community command repository
- **Monitoring**: Command execution metrics and logging

## Appendix A: Example Configurations

### A.1 Python Development Environment
```yaml
# ${XDG_CONFIG_HOME}/dox/commands/python.yaml
image: python:3.11-slim
volumes:
  - .:/workspace
  - ${HOME}/.cache/pip:/root/.cache/pip
environment:
  - PYTHONPATH
  - VIRTUAL_ENV
command: python
```

### A.2 Node.js with Custom Build
```yaml
# ${XDG_CONFIG_HOME}/dox/commands/node.yaml
image: node:custom
build:
  dockerfile_inline: |
    FROM node:20-alpine
    RUN npm install -g yarn pnpm
    WORKDIR /workspace
volumes:
  - .:/workspace
  - ${HOME}/.npm:/home/user/.npm
  - ${HOME}/.yarn:/home/user/.yarn
environment:
  - NODE_ENV
  - NPM_TOKEN
```

### A.3 Claude Code Integration
```yaml
# ${XDG_CONFIG_HOME}/dox/commands/claude.yaml
image: claude:local
build:
  dockerfile_inline: |
    FROM ubuntu:22.04
    RUN apt-get update && apt-get install -y curl git
    RUN curl -fsSL https://example.com/install-claude.sh | bash
    WORKDIR /workspace
    ENTRYPOINT ["claude"]
volumes:
  - .:/workspace
  - ${XDG_CONFIG_HOME}/claude:/home/user/.config/claude
  - ${HOME}/.ssh:/home/user/.ssh:ro
environment:
  - ANTHROPIC_API_KEY
  - TERM
  - LANG
  - LC_ALL
```

## Appendix B: Implementation Checklist

- [ ] Project structure creation
- [ ] Cobra CLI setup
- [ ] Viper configuration loading
- [ ] Docker SDK integration
- [ ] Container creation logic
- [ ] Signal forwarding implementation
- [ ] Volume mount processing
- [ ] Environment variable handling
- [ ] Built-in command implementations
- [ ] Inline Dockerfile building
- [ ] Podman compatibility layer
- [ ] Unit test suite
- [ ] Integration test suite
- [ ] Documentation
- [ ] Release automation
